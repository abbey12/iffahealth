name: Deploy to AWS

on:
  workflow_dispatch:
  push:
    branches: [ main, production ]

env:
  AWS_REGION: us-west-2
  EB_APPLICATION_NAME: Iffahealth-app
  EB_ENVIRONMENT_NAME: Iffahealth-prod
  FRONTEND_BUCKET: iffah-web-admin

  # Backend Environment Variables
  DATABASE_URL: postgresql://postgres:password@db.project.supabase.co:5432/postgres
  DB_HOST: db.project.supabase.co
  DB_PORT: 5432
  DB_NAME: postgres
  DB_USER: postgres
  DB_PASSWORD: password
  JWT_SECRET: your-super-secret-jwt-key-here
  JWT_EXPIRES_IN: 7d
  PORT: 3000
  NODE_ENV: production
  CORS_ORIGIN: "*"
  SMTP_HOST: smtp.gmail.com
  SMTP_PORT: 587
  SMTP_USER: your-email@gmail.com
  SMTP_PASS: your-app-password
  UPLOAD_DIR: uploads
  MAX_FILE_SIZE: 10485760
  RATE_LIMIT_WINDOW_MS: 900000
  RATE_LIMIT_MAX_REQUESTS: 100

jobs:
  prepare-env:
    runs-on: ubuntu-latest
    outputs:
      cname: ${{ steps.output-cname.outputs.cname }}
      url: ${{ steps.output-cname.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install EB CLI
        run: pip install --upgrade awsebcli

      - name: Initialize EB application
        run: |
          set -e
          eb init "$EB_APPLICATION_NAME" --region "$AWS_REGION" -p docker || true

      - name: Ensure environment exists (sample app)
        id: ensure-env
        run: |
          set -e
          if eb status "$EB_ENVIRONMENT_NAME" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Environment exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            # Create single-instance env with sample app to get CNAME quickly
            eb create "$EB_ENVIRONMENT_NAME" --single --instance_type t3.micro --sample --timeout 30
          fi

      - name: Wait for environment to be ready and get CNAME
        id: output-cname
        run: |
          set -e
          # Poll until we have a valid CNAME (not UNKNOWN)
          for i in {1..60}; do
            OUTPUT=$(eb status "$EB_ENVIRONMENT_NAME")
            echo "=== EB Status Output ==="
            echo "$OUTPUT"
            echo "========================"
            
            # Extract CNAME from "Application available at <cname>" message
            CNAME=$(echo "$OUTPUT" | grep -o 'Application available at [^.]*\.elasticbeanstalk\.com' | sed 's/Application available at //' || true)
            
            # Fallback: try to extract from CNAME field
            if [ -z "$CNAME" ] || [ "$CNAME" = "UNKNOWN" ]; then
              CNAME=$(echo "$OUTPUT" | sed -n 's/^[ ]*CNAME: \(.*\)$/\1/p' | tr -d '\r\n' || true)
            fi
            
            echo "Extracted CNAME: '$CNAME'"
            
            # Check if we have a valid CNAME
            if [ -n "$CNAME" ] && [ "$CNAME" != "UNKNOWN" ] && [[ "$CNAME" == *".elasticbeanstalk.com" ]]; then
              echo "cname=$CNAME" >> $GITHUB_OUTPUT
              echo "url=http://$CNAME" >> $GITHUB_OUTPUT
              echo "‚úÖ Resolved CNAME: $CNAME"
              break
            fi
            
            echo "Waiting for valid CNAME... (attempt $i/60)"
            sleep 20
          done
          
          # Final check
          if [ -z "$CNAME" ] || [ "$CNAME" = "UNKNOWN" ]; then
            echo "‚ùå Failed to resolve CNAME after 20 minutes"
            exit 1
          fi

  backend-deploy:
    runs-on: ubuntu-latest
    needs: prepare-env
    env:
      VERSION_LABEL: ${{ github.sha }}-${{ github.run_id }}-${{ github.run_attempt }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install EB CLI
        run: pip install --upgrade awsebcli

      - name: Create Dockerrun.aws.json
        run: |
          cat > backend/Dockerrun.aws.json <<EOF
          {
            "AWSEBDockerrunVersion": "1",
            "containerDefinitions": [
              {
                "name": "backend",
                "image": "iffahealth/backend:latest",
                "essential": true,
                "memory": 512,
                "portMappings": [
                  {
                    "hostPort": 80,
                    "containerPort": 3000
                  }
                ],
                "environment": [
                  {
                    "name": "DATABASE_URL",
                    "value": "${{ env.DATABASE_URL }}"
                  },
                  {
                    "name": "DB_HOST",
                    "value": "${{ env.DB_HOST }}"
                  },
                  {
                    "name": "DB_PORT",
                    "value": "${{ env.DB_PORT }}"
                  },
                  {
                    "name": "DB_NAME",
                    "value": "${{ env.DB_NAME }}"
                  },
                  {
                    "name": "DB_USER",
                    "value": "${{ env.DB_USER }}"
                  },
                  {
                    "name": "DB_PASSWORD",
                    "value": "${{ env.DB_PASSWORD }}"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "${{ env.JWT_SECRET }}"
                  },
                  {
                    "name": "JWT_EXPIRES_IN",
                    "value": "${{ env.JWT_EXPIRES_IN }}"
                  },
                  {
                    "name": "PORT",
                    "value": "${{ env.PORT }}"
                  },
                  {
                    "name": "NODE_ENV",
                    "value": "${{ env.NODE_ENV }}"
                  },
                  {
                    "name": "CORS_ORIGIN",
                    "value": "${{ env.CORS_ORIGIN }}"
                  },
                  {
                    "name": "SMTP_HOST",
                    "value": "${{ env.SMTP_HOST }}"
                  },
                  {
                    "name": "SMTP_PORT",
                    "value": "${{ env.SMTP_PORT }}"
                  },
                  {
                    "name": "SMTP_USER",
                    "value": "${{ env.SMTP_USER }}"
                  },
                  {
                    "name": "SMTP_PASS",
                    "value": "${{ env.SMTP_PASS }}"
                  },
                  {
                    "name": "UPLOAD_DIR",
                    "value": "${{ env.UPLOAD_DIR }}"
                  },
                  {
                    "name": "MAX_FILE_SIZE",
                    "value": "${{ env.MAX_FILE_SIZE }}"
                  },
                  {
                    "name": "RATE_LIMIT_WINDOW_MS",
                    "value": "${{ env.RATE_LIMIT_WINDOW_MS }}"
                  },
                  {
                    "name": "RATE_LIMIT_MAX_REQUESTS",
                    "value": "${{ env.RATE_LIMIT_MAX_REQUESTS }}"
                  }
                ]
              }
            ]
          }
          EOF

      - name: Init and deploy via EB CLI
        run: |
          set -e
          cd backend
          eb init "$EB_APPLICATION_NAME" --region "$AWS_REGION" -p docker || true
          eb use "$EB_ENVIRONMENT_NAME" || true
          eb deploy "$EB_ENVIRONMENT_NAME" -l "$VERSION_LABEL" --timeout 30
          eb status "$EB_ENVIRONMENT_NAME"

  backend-cloudfront:
    runs-on: ubuntu-latest
    needs: [prepare-env, backend-deploy]
    outputs:
      backend-cloudfront-url: ${{ steps.backend-cf.outputs.backend-cloudfront-url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Backend CloudFront Distribution
        id: backend-cf
        run: |
          set -e
          BACKEND_DOMAIN=$(echo "${{ needs.prepare-env.outputs.url }}" | sed 's|http://||')
          echo "Backend domain: $BACKEND_DOMAIN"
          
          # Check if backend CloudFront distribution already exists
          EXISTING_BACKEND_DIST=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Origins.Items[0].DomainName, '$BACKEND_DOMAIN')].Id" --output text || echo "")
          
          if [ -n "$EXISTING_BACKEND_DIST" ] && [ "$EXISTING_BACKEND_DIST" != "None" ]; then
            echo "Using existing backend CloudFront distribution: $EXISTING_BACKEND_DIST"
            BACKEND_CF_DOMAIN=$(aws cloudfront get-distribution --id "$EXISTING_BACKEND_DIST" --query 'Distribution.DomainName' --output text)
            echo "backend-cloudfront-url=https://$BACKEND_CF_DOMAIN" >> $GITHUB_OUTPUT
          else
            echo "Creating new backend CloudFront distribution..."
            
            # Create backend CloudFront distribution config
            cat > /tmp/backend-cf-config.json << EOF
          {
            "CallerReference": "Iffahealth-backend-${{ github.run_id }}-$(date +%s)",
            "Comment": "Iffahealth Backend API Distribution",
            "Origins": {
              "Quantity": 1,
              "Items": [
                {
                  "Id": "EB-Backend-$BACKEND_DOMAIN",
                  "DomainName": "$BACKEND_DOMAIN",
                  "CustomOriginConfig": {
                    "HTTPPort": 80,
                    "HTTPSPort": 443,
                    "OriginProtocolPolicy": "http-only"
                  }
                }
              ]
            },
            "DefaultCacheBehavior": {
              "TargetOriginId": "EB-Backend-$BACKEND_DOMAIN",
              "ViewerProtocolPolicy": "redirect-to-https",
              "MinTTL": 0,
              "DefaultTTL": 0,
              "MaxTTL": 0,
              "ForwardedValues": {
                "QueryString": true,
                "Headers": {
                  "Quantity": 3,
                  "Items": ["Authorization", "Content-Type", "Accept"]
                },
                "Cookies": {
                  "Forward": "all"
                }
              },
              "AllowedMethods": {
                "Quantity": 7,
                "Items": ["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"],
                "CachedMethods": {
                  "Quantity": 2,
                  "Items": ["GET", "HEAD"]
                }
              }
            },
            "Enabled": true,
            "PriceClass": "PriceClass_100"
          }
          EOF
            
            # Create the backend distribution
            BACKEND_DIST_ID=$(aws cloudfront create-distribution --distribution-config file:///tmp/backend-cf-config.json --query 'Distribution.Id' --output text)
            echo "Created backend CloudFront distribution: $BACKEND_DIST_ID"
            
            # Get the domain name
            BACKEND_CF_DOMAIN=$(aws cloudfront get-distribution --id "$BACKEND_DIST_ID" --query 'Distribution.DomainName' --output text)
            echo "backend-cloudfront-url=https://$BACKEND_CF_DOMAIN" >> $GITHUB_OUTPUT
            
            echo "‚ö†Ô∏è  Backend CloudFront distribution created but may take 15-20 minutes to deploy globally"
          fi

  frontend-deploy:
    runs-on: ubuntu-latest
    needs: [prepare-env, backend-cloudfront]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build frontend with CloudFront backend URL
        env:
          REACT_APP_API_URL: ${{ needs.backend-cloudfront.outputs.backend-cloudfront-url }}/api
        run: |
          set -e
          cd admin-web
          npm ci
          echo "Using REACT_APP_API_URL: $REACT_APP_API_URL"
          # Create React App automatically picks up env vars prefixed with REACT_APP_
          npm run build

      - name: Ensure S3 website bucket exists and is public
        run: |
          set -e
          BUCKET="${{ env.FRONTEND_BUCKET }}"
          REGION="${{ env.AWS_REGION }}"
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" --create-bucket-configuration LocationConstraint="$REGION"
            fi
          fi
          aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false
          cat > /tmp/policy.json <<POLICY
          {
            "Version": "2012-10-17",
            "Statement": [
              {"Sid": "PublicReadGetObject","Effect": "Allow","Principal": "*","Action": ["s3:GetObject"],"Resource": ["arn:aws:s3:::$BUCKET/*"]}
            ]
          }
          POLICY
          aws s3api put-bucket-policy --bucket "$BUCKET" --policy file:///tmp/policy.json
          aws s3 website s3://$BUCKET/ --index-document index.html --error-document index.html

      - name: Upload frontend to S3
        run: |
          aws s3 sync admin-web/build s3://${{ env.FRONTEND_BUCKET }} --delete --cache-control max-age=300

      - name: Create CloudFront Distribution
        id: cloudfront
        run: |
          set -e
          BUCKET="${{ env.FRONTEND_BUCKET }}"
          REGION="${{ env.AWS_REGION }}"
          ORIGIN_DOMAIN="$BUCKET.s3-website-$REGION.amazonaws.com"
          
          # Check if distribution already exists
          EXISTING_DIST=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Origins.Items[0].DomainName, '$BUCKET')].Id" --output text || echo "")
          
          if [ -n "$EXISTING_DIST" ] && [ "$EXISTING_DIST" != "None" ]; then
            echo "Using existing CloudFront distribution: $EXISTING_DIST"
            DOMAIN_NAME=$(aws cloudfront get-distribution --id "$EXISTING_DIST" --query 'Distribution.DomainName' --output text)
            echo "cloudfront-url=https://$DOMAIN_NAME" >> $GITHUB_OUTPUT
          else
            echo "Creating new CloudFront distribution..."
            
            # Create distribution config
            cat > /tmp/cf-config.json << EOF
          {
            "CallerReference": "Iffahealth-${{ github.run_id }}-$(date +%s)",
            "Comment": "Iffahealth Frontend Distribution",
            "DefaultRootObject": "index.html",
            "Origins": {
              "Quantity": 1,
              "Items": [
                {
                  "Id": "S3-Website-$BUCKET",
                  "DomainName": "$ORIGIN_DOMAIN",
                  "CustomOriginConfig": {
                    "HTTPPort": 80,
                    "HTTPSPort": 443,
                    "OriginProtocolPolicy": "http-only"
                  }
                }
              ]
            },
            "DefaultCacheBehavior": {
              "TargetOriginId": "S3-Website-$BUCKET",
              "ViewerProtocolPolicy": "redirect-to-https",
              "MinTTL": 0,
              "ForwardedValues": {
                "QueryString": false,
                "Cookies": {
                  "Forward": "none"
                }
              }
            },
            "CustomErrorResponses": {
              "Quantity": 1,
              "Items": [
                {
                  "ErrorCode": 404,
                  "ResponsePagePath": "/index.html",
                  "ResponseCode": "200",
                  "ErrorCachingMinTTL": 300
                }
              ]
            },
            "Enabled": true,
            "PriceClass": "PriceClass_100"
          }
          EOF
            
            # Create the distribution
            DIST_ID=$(aws cloudfront create-distribution --distribution-config file:///tmp/cf-config.json --query 'Distribution.Id' --output text)
            echo "Created CloudFront distribution: $DIST_ID"
            
            # Get the domain name
            DOMAIN_NAME=$(aws cloudfront get-distribution --id "$DIST_ID" --query 'Distribution.DomainName' --output text)
            echo "cloudfront-url=https://$DOMAIN_NAME" >> $GITHUB_OUTPUT
            
            echo "‚ö†Ô∏è  CloudFront distribution created but may take 15-20 minutes to deploy globally"
          fi

      - name: Output All URLs
        run: |
          echo "=== üöÄ Iffahealth Deployment Complete ==="
          echo ""
          echo "üì¶ S3 Website URL (HTTP): http://${{ env.FRONTEND_BUCKET }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
          echo "üåç Frontend CloudFront URL (HTTPS): ${{ steps.cloudfront.outputs.cloudfront-url }}"
          echo ""
          echo "üîó Backend EB URL (HTTP): ${{ needs.prepare-env.outputs.url }}"
          echo "‚ö° Backend CloudFront URL (HTTPS): ${{ needs.backend-cloudfront.outputs.backend-cloudfront-url }}"
          echo ""
          echo "‚úÖ RECOMMENDED: Use the CloudFront URLs for global, secure access!"
          echo "üîí Both frontend and backend now have HTTPS support via CloudFront"